// Configurable sherpa-onnx version (default: 1.12.24)
// Allow overriding the sherpa-onnx version via environment variable `SHERPA_ONNX_VERSION`.
// This lets CI or local devs set a single env var that influences both Android and iOS setup.
// Resolve sherpaOnnxVersion with the following precedence:
// 1. SHERPA_ONNX_VERSION env var (for special development use)
// 2. repo-level .sherpa_onnx_version file (pin per SDK release)
// 3. project property `sherpaOnnxVersion`
// 4. hardcoded default
def sherpaOnnxVersion = System.getenv('SHERPA_ONNX_VERSION')
if (!sherpaOnnxVersion) {
  def repoVerFile = new File(rootDir, '.sherpa_onnx_version')
  if (repoVerFile.exists()) {
    // Extract first semantic version token from the file (ignore comments)
    def matcher = (repoVerFile.text =~ /([0-9]+(\.[0-9]+)+)/)
    if (matcher) {
      sherpaOnnxVersion = matcher[0][0]
    } else {
      // fallback to project prop or default
      sherpaOnnxVersion = project.hasProperty('sherpaOnnxVersion') ? project.sherpaOnnxVersion : '1.12.24'
    }
  } else if (project.hasProperty('sherpaOnnxVersion')) {
    sherpaOnnxVersion = project.sherpaOnnxVersion
  } else {
    sherpaOnnxVersion = '1.12.24'
  }
}

def sherpaOnnxClassesDir = file("${buildDir}/sherpa-onnx-classes")

buildscript {
  ext.SherpaOnnx = [
    kotlinVersion: "2.0.21",
    minSdkVersion: 24,
    compileSdkVersion: 36,
    targetSdkVersion: 36
  ]

  ext.getExtOrDefault = { prop ->
    if (rootProject.ext.has(prop)) {
      return rootProject.ext.get(prop)
    }

    return SherpaOnnx[prop]
  }

  repositories {
    google()
    mavenCentral()
    maven { url 'https://plugins.gradle.org/m2/' }
  }

  dependencies {
    classpath "com.android.tools.build:gradle:8.7.2"
    // noinspection DifferentKotlinGradleVersion
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${getExtOrDefault('kotlinVersion')}"
    // Node Gradle plugin for running node/npx reliably from Gradle
    classpath "com.github.node-gradle:gradle-node-plugin:7.1.0"
  }
}


apply plugin: "com.android.library"
apply plugin: "kotlin-android"

// Standalone AAR build: set in root build.gradle (ext.standaloneAarBuild = true) or via -PstandaloneAarBuild=true
def isStandaloneAarBuild = rootProject.findProperty("standaloneAarBuild") in [true, "true"]
// Only apply React Native plugin when building inside a React Native app (e.g. example app).
if (!isStandaloneAarBuild) {
  apply plugin: "com.facebook.react"
}

android {
  namespace "com.sherpaonnx"

  compileSdkVersion getExtOrDefault("compileSdkVersion")

  // sherpa-onnx native .so files are provided from src/main/jniLibs/ (populated by
  // third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js or shipped in npm package).

  // Codegen Java output: always use the flat path. For app builds RNGP writes here directly;
  // for standalone AAR builds the codegen task normalises the nested output to this path.
  sourceSets.main.java.srcDirs += file("${buildDir}/generated/source/codegen/java")

  defaultConfig {
    minSdkVersion getExtOrDefault("minSdkVersion")
    targetSdkVersion getExtOrDefault("targetSdkVersion")

    // ProGuard rules to preserve classes/methods called from JNI
    consumerProguardFiles 'proguard-rules.pro'

    // NDK configuration
    ndkVersion getExtOrDefault("ndkVersion")
    externalNativeBuild {
      cmake {
        cppFlags "-std=c++17", "-Wall", "-Wextra", "-fvisibility=hidden"
        arguments "-DANDROID_STL=c++_shared"
      }
    }

    // Supported ABIs
    ndk {
      abiFilters "arm64-v8a", "armeabi-v7a", "x86", "x86_64"
    }
  }

  buildFeatures {
    buildConfig true
  }

  // CMake configuration
  externalNativeBuild {
    cmake {
      path "src/main/cpp/CMakeLists.txt"
      version "3.22.1"
    }
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }

  lint {
    disable "GradleCompatible"
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = '17'
  }

  // The build expects prebuilt .so files under src/main/jniLibs/<abi>/.
  // If missing, Gradle downloads them from this repo's GitHub Releases (see downloadNativeLibsIfNeeded).
  // Or run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and
  // third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js for local builds.

  def requiredAbis = ["arm64-v8a", "armeabi-v7a", "x86", "x86_64"]
  def requiredFfmpegSoFiles = [
    'libavcodec.so', 'libavformat.so', 'libavutil.so', 'libswresample.so', 'libavfilter.so', 'libshine.so'
  ]
  def requiredSherpaOnnxSoFiles = [
    'libsherpa-onnx-jni.so', 'libsherpa-onnx-c-api.so', 'libsherpa-onnx-cxx-api.so', 'libonnxruntime.so'
  ]

  def jniLibsDir = file("${projectDir}/src/main/jniLibs")

  def hasAllFfmpegLibs = {
    for (abi in requiredAbis) {
      def dir = new File(jniLibsDir, abi)
      if (!dir.exists()) return false
      for (soName in requiredFfmpegSoFiles) {
        if (!new File(dir, soName).exists()) return false
      }
    }
    return true
  }

  def hasAllSherpaLibs = {
    for (abi in requiredAbis) {
      def dir = new File(jniLibsDir, abi)
      if (!dir.exists()) return false
      for (soName in requiredSherpaOnnxSoFiles) {
        if (!new File(dir, soName).exists()) return false
      }
    }
    return true
  }

  def getGitHubRepo = {
    try {
      def proc = ['git', 'remote', 'get-url', 'origin'].execute(null, rootDir)
      proc.waitFor()
      if (proc.exitValue() != 0) return null
      def url = proc.text.trim()
      def m = (url =~ /github\.com[:\/]([^\/]+\/[^\/\s]+?)(\.git)?$/)
      return m ? m[0][1] : null
    } catch (Exception e) { return null }
  }

  def readReleaseTag = { File tagFile ->
    if (!tagFile.exists()) return null
    return tagFile.text.split(/\r?\n/).findResult { line ->
      def t = line.replaceAll(/\s*#.*$/, '').trim()
      t ? t : null
    }
  }

  task downloadNativeLibsIfNeeded {
    doLast {
      def repo = project.findProperty('prebuiltGitHubRepo') ?: getGitHubRepo()
      if (!repo) {
        if (!hasAllFfmpegLibs() || !hasAllSherpaLibs()) {
          throw new RuntimeException(
            "Native libs missing and GitHub repo unknown. Set -PprebuiltGitHubRepo=owner/repo or ensure git remote origin is a GitHub URL. " +
            "Alternatively run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js."
          )
        }
        return
      }
      def baseUrl = "https://github.com/${repo}/releases/download"
      def downloadDir = file("${buildDir}/prebuilt-downloads")
      downloadDir.mkdirs()

      if (!hasAllFfmpegLibs()) {
        def tagFile = file("${rootDir}/third_party/ffmpeg_prebuilt/ANDROID_RELEASE_TAG")
        def tag = readReleaseTag(tagFile)
        if (!tag) throw new RuntimeException("Missing or empty third_party/ffmpeg_prebuilt/ANDROID_RELEASE_TAG")
        def zipFile = new File(downloadDir, "ffmpeg-android.zip")
        def url = "${baseUrl}/${tag}/ffmpeg-android.zip"
        exec { commandLine 'curl', '-sSL', '-o', zipFile, url; workingDir projectDir }
        if (!zipFile.exists() || zipFile.length() == 0) throw new RuntimeException("Download failed or empty: ${url}")
        copy {
          from zipTree(zipFile)
          into jniLibsDir
        }
        println "Downloaded and extracted FFmpeg prebuilts from ${tag}"
      }

      if (!hasAllSherpaLibs()) {
        def tagFile = file("${rootDir}/third_party/sherpa-onnx-prebuilt/ANDROID_RELEASE_TAG")
        def tag = readReleaseTag(tagFile)
        if (!tag) throw new RuntimeException("Missing or empty third_party/sherpa-onnx-prebuilt/ANDROID_RELEASE_TAG")
        def zipFile = new File(downloadDir, "sherpa-onnx-android.zip")
        def url = "${baseUrl}/${tag}/sherpa-onnx-android.zip"
        exec { commandLine 'curl', '-sSL', '-o', zipFile, url; workingDir projectDir }
        if (!zipFile.exists() || zipFile.length() == 0) throw new RuntimeException("Download failed or empty: ${url}")
        copy {
          from zipTree(zipFile)
          into jniLibsDir
        }
        println "Downloaded and extracted sherpa-onnx prebuilts from ${tag}"
      }
    }
  }

  task checkJniLibs {
    dependsOn downloadNativeLibsIfNeeded
    doLast {
      requiredAbis.each { abi ->
        def dir = file("${projectDir}/src/main/jniLibs/${abi}")
        if (!dir.exists()) {
          throw new RuntimeException("Missing native libs for ABI ${abi} in ${dir}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js or ensure ANDROID_RELEASE_TAG releases exist.")
        }
        requiredFfmpegSoFiles.each { soName ->
          def soFile = new File(dir, soName)
          if (!soFile.exists()) {
            throw new RuntimeException("Missing required FFmpeg library '${soName}' for ABI ${abi}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js")
          }
        }
        requiredSherpaOnnxSoFiles.each { soName ->
          def soFile = new File(dir, soName)
          if (!soFile.exists()) {
            throw new RuntimeException("Missing required sherpa-onnx library '${soName}' for ABI ${abi}. Run third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js")
          }
        }
      }
    }
  }

  // Ensure JNI libs exist before build (fail fast with clear message)
  preBuild.dependsOn checkJniLibs
}


repositories {
  mavenCentral()
  google()
  maven { url 'https://jitpack.io' }
}


def kotlin_version = getExtOrDefault("kotlinVersion")

dependencies {
  // React Native dependency: explicit version ensures IDE (VS Code Kotlin LSP) and standalone
  // AAR builds can resolve com.facebook.react types. When consumed by a React Native app,
  // Gradle's dependency resolution picks the app's react-android version (typically higher).
  implementation "com.facebook.react:react-android:0.83.0"
  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"

  // sherpa-onnx Java/Kotlin classes only (extracted from AAR); native .so are from prebuilts in jniLibs.
  implementation fileTree(dir: sherpaOnnxClassesDir, include: '*.jar')

  // Play Asset Delivery: optional for getAssetPackPath (returns null if not used)
  implementation "com.google.android.play:asset-delivery:2.3.0"
}

// Extract Java/Kotlin classes from sherpa-onnx AAR (native .so built separately with QNN support)
configurations {
  sherpaOnnxClasses {
    canBeResolved = true
    canBeConsumed = false
  }
}
dependencies {
  sherpaOnnxClasses "com.github.k2-fsa:sherpa-onnx:v${sherpaOnnxVersion}"
}
def extractSherpaOnnxClasses = tasks.register("extractSherpaOnnxClasses") {
  outputs.dir sherpaOnnxClassesDir
  doLast {
    sherpaOnnxClassesDir.mkdirs()
    def foundAar = false
    configurations.sherpaOnnxClasses.resolvedConfiguration.resolvedArtifacts.each { artifact ->
      if (artifact.file.name.endsWith(".aar")) {
        foundAar = true
        copy {
          from(zipTree(artifact.file)) { include "classes.jar" }
          into sherpaOnnxClassesDir
        }
      }
    }
    if (!foundAar) {
      throw new RuntimeException("No sherpa-onnx AAR found. Check sherpaOnnxVersion and JitPack resolution.")
    }
  }
}

// Codegen for TurboModule spec; in separate script to avoid Gradle 9 Groovy "source is null" with NodeTask in main script.
apply from: file("${project.projectDir}/codegen.gradle")

afterEvaluate {
  tasks.matching { it.name.contains("configureCMake") || it.name.contains("externalNativeBuild") }.configureEach {
    dependsOn extractSherpaOnnxClasses
  }

  // With includesGeneratedCode=false, codegen is always run by our custom task (not RNGP).
  // Kotlin compile must depend on it for both standalone AAR and app-dependency builds.
  def codegenJavaDir = project.file("${project.buildDir}/generated/source/codegen/java")
  tasks.matching { it.name == "compileReleaseKotlin" || it.name == "compileDebugKotlin" }.configureEach {
    dependsOn extractSherpaOnnxClasses
    dependsOn tasks.named('generateCodegenSpec')
    inputs.dir(codegenJavaDir)
  }
}