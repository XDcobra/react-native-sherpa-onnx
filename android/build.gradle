// Configurable sherpa-onnx version (default: 1.12.24)
// Allow overriding the sherpa-onnx version via environment variable `SHERPA_ONNX_VERSION`.
// This lets CI or local devs set a single env var that influences both Android and iOS setup.
// Resolve sherpaOnnxVersion with the following precedence:
// 1. SHERPA_ONNX_VERSION env var (for special development use)
// 2. repo-level .sherpa_onnx_version file (pin per SDK release)
// 3. project property `sherpaOnnxVersion`
// 4. hardcoded default
def sherpaOnnxVersion = System.getenv('SHERPA_ONNX_VERSION')
if (!sherpaOnnxVersion) {
  def repoVerFile = new File(rootDir, '.sherpa_onnx_version')
  if (repoVerFile.exists()) {
    // Extract first semantic version token from the file (ignore comments)
    def matcher = (repoVerFile.text =~ /([0-9]+(\.[0-9]+)+)/)
    if (matcher) {
      sherpaOnnxVersion = matcher[0][0]
    } else {
      // fallback to project prop or default
      sherpaOnnxVersion = project.hasProperty('sherpaOnnxVersion') ? project.sherpaOnnxVersion : '1.12.24'
    }
  } else if (project.hasProperty('sherpaOnnxVersion')) {
    sherpaOnnxVersion = project.sherpaOnnxVersion
  } else {
    sherpaOnnxVersion = '1.12.24'
  }
}

buildscript {
  ext.SherpaOnnx = [
    kotlinVersion: "2.0.21",
    minSdkVersion: 24,
    compileSdkVersion: 36,
    targetSdkVersion: 36
  ]

  ext.getExtOrDefault = { prop ->
    if (rootProject.ext.has(prop)) {
      return rootProject.ext.get(prop)
    }

    return SherpaOnnx[prop]
  }

  repositories {
    google()
    mavenCentral()
    maven { url 'https://plugins.gradle.org/m2/' }
  }

  dependencies {
    classpath "com.android.tools.build:gradle:8.7.2"
    // noinspection DifferentKotlinGradleVersion
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${getExtOrDefault('kotlinVersion')}"
    // Node Gradle plugin for running npx reliably from Gradle
    classpath "com.github.node-gradle:gradle-node-plugin:7.1.0"
  }
}


apply plugin: "com.android.library"
apply plugin: "kotlin-android"

// Standalone AAR build: set in root build.gradle (ext.standaloneAarBuild = true) or via -PstandaloneAarBuild=true
def isStandaloneAarBuild = rootProject.findProperty("standaloneAarBuild") in [true, "true"]
// Only apply React Native plugin when building inside a React Native app (e.g. example app).
if (!isStandaloneAarBuild) {
  apply plugin: "com.facebook.react"
}

android {
  namespace "com.sherpaonnx"

  compileSdkVersion getExtOrDefault("compileSdkVersion")

  // Include extracted sherpa-onnx .so (from extractNativeLibs) so they are merged into the AAR
  sourceSets.main.jniLibs.srcDirs += file("${buildDir}/extracted_native_libs/jni")

  // Codegen output (run for both example-app and standalone AAR). includesGeneratedCode=true â†’ script writes to this path; app CMake expects build/generated/source/codegen/jni.
  sourceSets.main.java.srcDirs += file("${buildDir}/generated/source/codegen/java")

  defaultConfig {
    minSdkVersion getExtOrDefault("minSdkVersion")
    targetSdkVersion getExtOrDefault("targetSdkVersion")

    // NDK configuration
    ndkVersion getExtOrDefault("ndkVersion")
    externalNativeBuild {
      cmake {
        cppFlags "-std=c++17", "-Wall", "-Wextra", "-fvisibility=hidden"
        arguments "-DANDROID_STL=c++_shared"
      }
    }

    // Supported ABIs
    ndk {
      abiFilters "arm64-v8a", "armeabi-v7a", "x86", "x86_64"
    }
  }

  buildFeatures {
    buildConfig true
  }

  // CMake configuration
  externalNativeBuild {
    cmake {
      path "src/main/cpp/CMakeLists.txt"
      version "3.22.1"
    }
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }

  lint {
    disable "GradleCompatible"
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = '17'
  }

  // The build expects prebuilt .so files to exist under this module's
  // `src/main/jniLibs/<abi>/` directory. Use the helper script
  // `third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js` to install
  // the required .so files before running Gradle.

  def requiredAbis = ["arm64-v8a", "armeabi-v7a", "x86", "x86_64"]

  task checkJniLibs {
    doLast {
      // Explicitly require FFmpeg shared libraries to be present for each ABI.
      def requiredSoFiles = [
        'libavcodec.so',
        'libavformat.so',
        'libavutil.so',
        'libswresample.so',
        'libavfilter.so',
        // libshine is needed when FFmpeg was built with libshine (MP3 encoder)
        'libshine.so'
      ]

      requiredAbis.each { abi ->
        def dir = file("${projectDir}/src/main/jniLibs/${abi}")
        if (!dir.exists()) {
          throw new RuntimeException("Missing native libs for ABI ${abi} in ${dir}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js or ensure the sherpa-onnx AAR provides FFmpeg .so files.")
        }

        requiredSoFiles.each { soName ->
          def soFile = new File(dir, soName)
          if (!soFile.exists()) {
            throw new RuntimeException("Missing required FFmpeg library '${soName}' for ABI ${abi} in ${dir}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js or ensure the sherpa-onnx AAR provides it.")
          }
        }
      }
    }
  }

  // Ensure JNI libs exist before build (fail fast with clear message)
  preBuild.dependsOn checkJniLibs
}


repositories {
  mavenCentral()
  google()
  maven { url 'https://jitpack.io' }
}


def kotlin_version = getExtOrDefault("kotlinVersion")

dependencies {
  // When inside a React Native app: use the app's react-android version.
  // When building standalone AAR: use a fixed version so the Kotlin/React types compile (your sources reference them).
  if (isStandaloneAarBuild) {
    implementation "com.facebook.react:react-android:0.83.0"
  } else {
    implementation "com.facebook.react:react-android"
  }
  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"

  // sherpa-onnx prebuilt AAR from JitPack
  // This includes the native .so libraries for all ABIs
  implementation "com.github.k2-fsa:sherpa-onnx:v${sherpaOnnxVersion}"

  // Play Asset Delivery: optional for getAssetPackPath (returns null if not used)
  implementation "com.google.android.play:asset-delivery:2.2.1"
}

// Create resolvable configuration for extraction
configurations {
  extractNativeLibs {
    canBeResolved = true
    canBeConsumed = false
  }
}

dependencies {
  extractNativeLibs "com.github.k2-fsa:sherpa-onnx:v${sherpaOnnxVersion}"
}

// Extract native libraries from AAR before CMake runs
def extractNativeLibs = tasks.register("extractNativeLibs") {
  doLast {
    def extractedLibsDir = file("${buildDir}/extracted_native_libs")
    extractedLibsDir.mkdirs()
    
    def resolvedConfig = configurations.extractNativeLibs.resolvedConfiguration
    def foundAar = false
    
    resolvedConfig.resolvedArtifacts.each { artifact ->
      def aarFile = artifact.file
      println "Checking artifact: ${aarFile.name} (exists: ${aarFile.exists()})"
      
      if (aarFile.exists() && (aarFile.name.endsWith(".aar") || aarFile.name.endsWith(".jar"))) {
        foundAar = true
        println "Extracting native libraries from: ${aarFile.name}"
        
        copy {
          from(zipTree(aarFile)) {
            include "jni/**/*.so"
          }
          into extractedLibsDir
        }
        
        // Verify extraction succeeded
        def extractedFiles = fileTree(extractedLibsDir).matching { include "**/*.so" }
        if (extractedFiles.isEmpty()) {
          println "WARNING: No .so files extracted from ${aarFile.name}"
          println "Contents of AAR:"
          zipTree(aarFile).each { entry ->
            if (entry.name.contains("jni") || entry.name.endsWith(".so")) {
              println "  ${entry.name}"
            }
          }
        }
      }
    }
    
    if (!foundAar) {
      throw new RuntimeException("No AAR file found for sherpa-onnx. Check if the dependency is correctly resolved.")
    }
  }
}

// Task to check and log header source before CMake runs
def checkHeaderSource = tasks.register("checkHeaderSource") {
  doLast {
    def cppDir = file("src/main/cpp")
    def bundledHeaderPath = file("${cppDir}/include/sherpa-onnx/c-api/cxx-api.h")
    
    if (bundledHeaderPath.exists()) {
      println "[SherpaOnnx] Header files present"
    } else {
      println "[SherpaOnnx] ERROR: Header files not found at ${bundledHeaderPath.absolutePath}"
      throw new RuntimeException("Header files not found. Run 'yarn setup-assets' or 'yarn copy-headers'")
    }
  }
}

// Standalone AAR build: run React Native codegen so NativeSherpaOnnxSpec is generated (no stub needed)

// Ensure Node plugin is applied (used to run npx reliably)
apply plugin: 'com.github.node-gradle.node'

// Configure Node (plugin will download if necessary)
// Resolve desired Node version from library root .nvmrc so codegen uses same Node when built from app or standalone.
def projectNodeVersion = null
def libraryRootForNode = project.projectDir.parentFile
def nvmrcFile = file("${libraryRootForNode}/.nvmrc")
if (nvmrcFile.exists()) {
  projectNodeVersion = nvmrcFile.text.readLines().find { it?.trim() }?.trim()
  if (projectNodeVersion?.startsWith('v')) {
    projectNodeVersion = projectNodeVersion.substring(1)
  }
}

node {
  version = projectNodeVersion
  download = false // Don't download if not needed - use system Node if it matches the version in .nvmrc (common in dev environments)
}

// Two implementations: NodeTask (runs the codegen script via node) and NpxTask (runs via npx).
// Toggle between them with -PuseNpx=true (defaults to NodeTask).
// Use the library root (parent of android/), not rootProject, so codegen works when this module
// is built from the repo root (standalone AAR) or from an app (e.g. example/android).
def libraryRoot = project.projectDir.parentFile
// Single path on all platforms: with codegenConfig.includesGeneratedCode=true the script uses -o directly (no nested android/app/build/...).
def outDir = file("${project.buildDir}/generated/source/codegen")

tasks.register("generateCodegenSpecNode", com.github.gradle.node.task.NodeTask) {
  onlyIf { !project.hasProperty('useNpx') || project.property('useNpx') != 'true' }
  workingDir = libraryRoot
  inputs.dir(file("${libraryRoot}/src"))
  inputs.file(file("${libraryRoot}/package.json"))
  outputs.dir(outDir)

  doFirst {
    if (!file("${libraryRoot}/node_modules/react-native").exists()) {
      throw new RuntimeException(
        "Codegen requires node_modules at library root. Run 'yarn install' (or npm install) in ${libraryRoot}, then rebuild."
      )
    }
    outDir.mkdirs()
  }

  script = file("${libraryRoot}/node_modules/react-native/scripts/generate-codegen-artifacts.js")
  args = [
    '-p', libraryRoot.absolutePath.replace("\\", "/"),
    '-t', 'android',
    '-o', outDir.absolutePath.replace("\\", "/"),
    '-s', 'library'
  ]

  environment = ['CI': 'true']
}

// Alias task: depend on the Node-based implementation only.
tasks.register('generateCodegenSpec') {
  dependsOn tasks.named('generateCodegenSpecNode')
}

// Make CMake depend on extraction and header verification - ensure they run before any CMake task
afterEvaluate {
  tasks.matching { it.name.contains("configureCMake") || it.name.contains("externalNativeBuild") }.configureEach {
    dependsOn extractNativeLibs
    dependsOn checkHeaderSource
  }

  // Ensure extracted native libs are available before merge (so AAR contains sherpa-onnx .so)
  tasks.matching { it.name == "mergeReleaseNativeLibs" }.configureEach {
    dependsOn extractNativeLibs
  }

  // Also ensure all extraction and verification tasks run before preBuild
  preBuild.dependsOn extractNativeLibs
  preBuild.dependsOn checkHeaderSource

  // Compile (debug + release) only after codegen; ensures example-app and standalone AAR both see the spec and app CMake finds jni.
  def codegenJavaDir = project.file("${project.buildDir}/generated/source/codegen/java")
  tasks.matching { it.name == "compileReleaseKotlin" || it.name == "compileDebugKotlin" }.configureEach {
    dependsOn tasks.named('generateCodegenSpec')
    inputs.dir(codegenJavaDir)
  }
}