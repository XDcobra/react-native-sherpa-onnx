// Configurable sherpa-onnx version (default: 1.12.24)
// Allow overriding the sherpa-onnx version via environment variable `SHERPA_ONNX_VERSION`.
// This lets CI or local devs set a single env var that influences both Android and iOS setup.
// Resolve sherpaOnnxVersion with the following precedence:
// 1. SHERPA_ONNX_VERSION env var (for special development use)
// 2. repo-level .sherpa_onnx_version file (pin per SDK release)
// 3. project property `sherpaOnnxVersion`
// 4. hardcoded default
def sherpaOnnxVersion = System.getenv('SHERPA_ONNX_VERSION')
if (!sherpaOnnxVersion) {
  def repoVerFile = new File(rootDir, '.sherpa_onnx_version')
  if (repoVerFile.exists()) {
    // Extract first semantic version token from the file (ignore comments)
    def matcher = (repoVerFile.text =~ /([0-9]+(\.[0-9]+)+)/)
    if (matcher) {
      sherpaOnnxVersion = matcher[0][0]
    } else {
      // fallback to project prop or default
      sherpaOnnxVersion = project.hasProperty('sherpaOnnxVersion') ? project.sherpaOnnxVersion : '1.12.24'
    }
  } else if (project.hasProperty('sherpaOnnxVersion')) {
    sherpaOnnxVersion = project.sherpaOnnxVersion
  } else {
    sherpaOnnxVersion = '1.12.24'
  }
}

def sherpaOnnxClassesDir = file("${buildDir}/sherpa-onnx-classes")

buildscript {
  ext.SherpaOnnx = [
    kotlinVersion: "2.0.21",
    minSdkVersion: 24,
    compileSdkVersion: 36,
    targetSdkVersion: 36
  ]

  ext.getExtOrDefault = { prop ->
    if (rootProject.ext.has(prop)) {
      return rootProject.ext.get(prop)
    }

    return SherpaOnnx[prop]
  }

  repositories {
    google()
    mavenCentral()
    maven { url 'https://plugins.gradle.org/m2/' }
  }

  dependencies {
    classpath "com.android.tools.build:gradle:8.7.2"
    // noinspection DifferentKotlinGradleVersion
    classpath "org.jetbrains.kotlin:kotlin-gradle-plugin:${getExtOrDefault('kotlinVersion')}"
    // Node Gradle plugin for running node/npx reliably from Gradle
    classpath "com.github.node-gradle:gradle-node-plugin:7.1.0"
  }
}


apply plugin: "com.android.library"
apply plugin: "kotlin-android"

// Standalone AAR build: set in root build.gradle (ext.standaloneAarBuild = true) or via -PstandaloneAarBuild=true
def isStandaloneAarBuild = rootProject.findProperty("standaloneAarBuild") in [true, "true"]
// Only apply React Native plugin when building inside a React Native app (e.g. example app).
if (!isStandaloneAarBuild) {
  apply plugin: "com.facebook.react"
}

android {
  namespace "com.sherpaonnx"

  compileSdkVersion getExtOrDefault("compileSdkVersion")

  // sherpa-onnx native .so files are provided from src/main/jniLibs/ (populated by
  // third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js or shipped in npm package).

  // Codegen Java output: always use the flat path. For app builds RNGP writes here directly;
  // for standalone AAR builds the codegen task normalises the nested output to this path.
  sourceSets.main.java.srcDirs += file("${buildDir}/generated/source/codegen/java")

  defaultConfig {
    minSdkVersion getExtOrDefault("minSdkVersion")
    targetSdkVersion getExtOrDefault("targetSdkVersion")

    // ProGuard rules to preserve classes/methods called from JNI
    consumerProguardFiles 'proguard-rules.pro'

    // NDK configuration
    ndkVersion getExtOrDefault("ndkVersion")
    externalNativeBuild {
      cmake {
        cppFlags "-std=c++17", "-Wall", "-Wextra", "-fvisibility=hidden"
        arguments "-DANDROID_STL=c++_shared"
      }
    }

    // Supported ABIs
    ndk {
      abiFilters "arm64-v8a", "armeabi-v7a", "x86", "x86_64"
    }
  }

  buildFeatures {
    buildConfig true
  }

  // CMake configuration
  externalNativeBuild {
    cmake {
      path "src/main/cpp/CMakeLists.txt"
      version "3.22.1"
    }
  }

  buildTypes {
    release {
      minifyEnabled false
    }
  }

  lint {
    disable "GradleCompatible"
  }

  compileOptions {
    sourceCompatibility JavaVersion.VERSION_17
    targetCompatibility JavaVersion.VERSION_17
  }

  kotlinOptions {
    jvmTarget = '17'
  }

  // The build expects prebuilt .so files under src/main/jniLibs/<abi>/ and (for sherpa-onnx) C API headers
  // under src/main/cpp/include/sherpa-onnx/c-api/. If missing, Gradle downloads the sherpa-onnx-android
  // release zip from this repo's GitHub Releases and extracts both libs and headers (single source).
  // Or run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and
  // third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js for local builds (headers then from release or CI copy).

  def requiredAbis = ["arm64-v8a", "armeabi-v7a", "x86", "x86_64"]
  def requiredFfmpegSoFiles = [
    'libavcodec.so', 'libavformat.so', 'libavutil.so', 'libswresample.so', 'libavfilter.so', 'libshine.so'
  ]
  def requiredSherpaOnnxSoFiles = [
    'libsherpa-onnx-jni.so', 'libsherpa-onnx-c-api.so', 'libsherpa-onnx-cxx-api.so', 'libonnxruntime.so'
  ]

  def jniLibsDir = file("${projectDir}/src/main/jniLibs")

  def hasAllFfmpegLibs = {
    for (abi in requiredAbis) {
      def dir = new File(jniLibsDir, abi)
      if (!dir.exists()) return false
      for (soName in requiredFfmpegSoFiles) {
        if (!new File(dir, soName).exists()) return false
      }
    }
    return true
  }

  def hasAllSherpaLibs = {
    for (abi in requiredAbis) {
      def dir = new File(jniLibsDir, abi)
      if (!dir.exists()) return false
      for (soName in requiredSherpaOnnxSoFiles) {
        if (!new File(dir, soName).exists()) return false
      }
    }
    return true
  }

  def hasSherpaHeaders = {
    return new File(projectDir, "src/main/cpp/include/sherpa-onnx/c-api/c-api.h").exists()
  }

  def getGitHubRepo = {
    try {
      def proc = ['git', 'remote', 'get-url', 'origin'].execute(null, rootDir)
      proc.waitFor()
      if (proc.exitValue() != 0) return null
      def url = proc.text.trim()
      def m = (url =~ /github\.com[:\/]([^\/]+\/[^\/\s]+?)(\.git)?$/)
      return m ? m[0][1] : null
    } catch (Exception e) { return null }
  }

  def readReleaseTag = { File tagFile ->
    if (!tagFile.exists()) return null
    return tagFile.text.split(/\r?\n/).findResult { line ->
      def t = line.replaceAll(/\s*#.*$/, '').trim()
      t ? t : null
    }
  }

  task downloadNativeLibsIfNeeded {
    doLast {
      def repo = project.findProperty('prebuiltGitHubRepo') ?: getGitHubRepo()
      if (!repo) {
        if (!hasAllFfmpegLibs() || !hasAllSherpaLibs()) {
          throw new RuntimeException(
            "Native libs missing and GitHub repo unknown. Set -PprebuiltGitHubRepo=owner/repo or ensure git remote origin is a GitHub URL. " +
            "Alternatively run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js."
          )
        }
        return
      }
      def baseUrl = "https://github.com/${repo}/releases/download"
      def downloadDir = file("${buildDir}/prebuilt-downloads")
      downloadDir.mkdirs()

      if (!hasAllFfmpegLibs()) {
        def tagFile = file("${projectDir.parent}/third_party/ffmpeg_prebuilt/ANDROID_RELEASE_TAG")
        def tag = readReleaseTag(tagFile)
        if (!tag) throw new RuntimeException("Missing or empty third_party/ffmpeg_prebuilt/ANDROID_RELEASE_TAG")
        def zipFile = new File(downloadDir, "ffmpeg-android.zip")
        def url = "${baseUrl}/${tag}/ffmpeg-android.zip"
        exec { commandLine 'curl', '-sSL', '-o', zipFile, url; workingDir projectDir }
        if (!zipFile.exists() || zipFile.length() == 0) throw new RuntimeException("Download failed or empty: ${url}")
        def ffmpegExtractDir = new File(downloadDir, "ffmpeg-extract")
        if (ffmpegExtractDir.exists()) ffmpegExtractDir.deleteDir()
        ffmpegExtractDir.mkdirs()
        copy { from zipTree(zipFile); into ffmpegExtractDir }
        copy {
          from fileTree(ffmpegExtractDir) { include 'arm64-v8a/**', 'armeabi-v7a/**', 'x86/**', 'x86_64/**' }
          into jniLibsDir
        }
        def ffmpegIncludeDir = file("${projectDir}/src/main/cpp/include/ffmpeg")
        def ffmpegIncludeInZip = new File(ffmpegExtractDir, "include")
        if (ffmpegIncludeInZip.exists()) {
          copy { from fileTree(ffmpegIncludeInZip); into ffmpegIncludeDir }
        }
        println "Downloaded and extracted FFmpeg prebuilts (libs + include) from ${tag}"
      }

      if (!hasAllSherpaLibs() || !hasSherpaHeaders()) {
        def tagFile = file("${projectDir.parent}/third_party/sherpa-onnx-prebuilt/ANDROID_RELEASE_TAG")
        def tag = readReleaseTag(tagFile)
        if (!tag) throw new RuntimeException("Missing or empty third_party/sherpa-onnx-prebuilt/ANDROID_RELEASE_TAG")
        def zipFile = new File(downloadDir, "sherpa-onnx-android.zip")
        def url = "${baseUrl}/${tag}/sherpa-onnx-android.zip"
        exec { commandLine 'curl', '-sSL', '-o', zipFile, url; workingDir projectDir }
        if (!zipFile.exists() || zipFile.length() == 0) throw new RuntimeException("Download failed or empty: ${url}")
        def sherpaExtractDir = new File(downloadDir, "sherpa-onnx-extract")
        if (sherpaExtractDir.exists()) sherpaExtractDir.deleteDir()
        sherpaExtractDir.mkdirs()
        copy {
          from zipTree(zipFile)
          into sherpaExtractDir
        }
        copy {
          from fileTree(sherpaExtractDir) { include 'arm64-v8a/**', 'armeabi-v7a/**', 'x86/**', 'x86_64/**' }
          into jniLibsDir
        }
        def includeSherpaDir = file("${projectDir}/src/main/cpp/include/sherpa-onnx")
        copy {
          from fileTree(sherpaExtractDir) { include 'c-api/**' }
          into includeSherpaDir
        }
        def sherpaJavaJar = new File(sherpaExtractDir, "java/classes.jar")
        if (sherpaJavaJar.exists()) {
          sherpaOnnxClassesDir.mkdirs()
          copy { from sherpaJavaJar; into sherpaOnnxClassesDir }
        }
        println "Downloaded and extracted sherpa-onnx prebuilts (libs + C API headers + java/classes.jar) from ${tag}"
      }
    }
  }

  task checkJniLibs {
    dependsOn downloadNativeLibsIfNeeded
    doLast {
      requiredAbis.each { abi ->
        def dir = file("${projectDir}/src/main/jniLibs/${abi}")
        if (!dir.exists()) {
          throw new RuntimeException("Missing native libs for ABI ${abi} in ${dir}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js and third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js or ensure ANDROID_RELEASE_TAG releases exist.")
        }
        requiredFfmpegSoFiles.each { soName ->
          def soFile = new File(dir, soName)
          if (!soFile.exists()) {
            throw new RuntimeException("Missing required FFmpeg library '${soName}' for ABI ${abi}. Run third_party/ffmpeg_prebuilt/copy_prebuilts_to_sdk.js")
          }
        }
        requiredSherpaOnnxSoFiles.each { soName ->
          def soFile = new File(dir, soName)
          if (!soFile.exists()) {
            throw new RuntimeException("Missing required sherpa-onnx library '${soName}' for ABI ${abi}. Run third_party/sherpa-onnx-prebuilt/copy_prebuilts_to_sdk.js")
          }
        }
      }
    }
  }

  // Ensure JNI libs exist before build (fail fast with clear message)
  preBuild.dependsOn checkJniLibs
}


repositories {
  mavenCentral()
  google()
}


def kotlin_version = getExtOrDefault("kotlinVersion")

// Populate sherpa-onnx-classes from (1) release zip (done in downloadNativeLibsIfNeeded) or (2) local prebuilts. No JitPack.
// Registered before dependencies so builtBy(extractSherpaOnnxClasses) can resolve.
def extractSherpaOnnxClasses = tasks.register("extractSherpaOnnxClasses") {
  outputs.dir sherpaOnnxClassesDir
  doLast {
    sherpaOnnxClassesDir.mkdirs()
    if (sherpaOnnxClassesDir.listFiles()?.any { it.name.endsWith('.jar') }) return
    def localJar = file("${projectDir.parent}/third_party/sherpa-onnx-prebuilt/android/java/classes.jar")
    if (localJar.exists()) {
      copy { from localJar; into sherpaOnnxClassesDir }
      println "Using sherpa-onnx classes.jar from local prebuilts"
      return
    }
    throw new RuntimeException(
      "Missing sherpa-onnx classes.jar. Run third_party/sherpa-onnx-prebuilt/build_sherpa_onnx.sh (produces android/java/classes.jar) or use a release that includes java/classes.jar.")
  }
}

dependencies {
  // React Native dependency: explicit version ensures IDE (VS Code Kotlin LSP) and standalone
  // AAR builds can resolve com.facebook.react types. When consumed by a React Native app,
  // Gradle's dependency resolution picks the app's react-android version (typically higher).
  implementation "com.facebook.react:react-android:0.83.0"
  implementation "org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version"

  // sherpa-onnx Java API (classes.jar from build_sherpa_onnx.sh or release zip); native .so from prebuilts. No JitPack.
  implementation fileTree(dir: sherpaOnnxClassesDir, include: '*.jar').builtBy(tasks.named('extractSherpaOnnxClasses'))

  // Play Asset Delivery: optional for getAssetPackPath (returns null if not used)
  implementation "com.google.android.play:asset-delivery:2.3.0"
}

// Codegen for TurboModule spec; in separate script to avoid Gradle 9 Groovy "source is null" with NodeTask in main script.
apply from: file("${project.projectDir}/codegen.gradle")

afterEvaluate {
  if (!isStandaloneAarBuild && tasks.findByName("downloadNativeLibsIfNeeded") != null) {
    tasks.named("extractSherpaOnnxClasses").configure { dependsOn tasks.named("downloadNativeLibsIfNeeded") }
  }
  tasks.matching { it.name.contains("configureCMake") || it.name.contains("externalNativeBuild") }.configureEach {
    dependsOn extractSherpaOnnxClasses
  }

  // With includesGeneratedCode=false, codegen is always run by our custom task (not RNGP).
  // Kotlin compile must depend on it for both standalone AAR and app-dependency builds.
  def codegenJavaDir = project.file("${project.buildDir}/generated/source/codegen/java")
  tasks.matching { it.name == "compileReleaseKotlin" || it.name == "compileDebugKotlin" }.configureEach {
    dependsOn extractSherpaOnnxClasses
    dependsOn tasks.named('generateCodegenSpec')
    inputs.dir(codegenJavaDir)
  }
}